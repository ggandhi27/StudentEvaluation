Introduction:
+++++++++++++++

The Bohemian approach of developing, testing and deploying the softwares
is not very efficient.
The process of developing and releasing the software updates can be
complex and if not handled at the right time, it me lead the developer 
and his team into a huge problem. To avoid such kind of issues while 
developing a software and to develop, test and release the software updates
at the right time there are different strategies of software development
and testing, which me help the developers to meticulously code the software
and to deploy them with more efficiency.

Continuous Integration:
------------------------

Reference : https://www.linkedin.com/pulse/introduction-continuous-integration-delivery-rajesh-gurram

When a software is developed by meticulously following the techniques of
continuous integration the developers are supposed to merge or integrate 
their branches frequently, where the frequency can be several times a day.
Continuous Integration encourages us to avoid the strategy of developing
different modules and features of a project in isolation and to integrate
the complete code at the end of the development cycle. The basic approach 
behind the strategy of Continuous Integration is to reduce the cost of 
integration of code by applying the process of integration at an early 
stage of development and that too quite frequent, so that all the issues
which are suspected to occur in the project can be avoided and can be considered
at an early stage of development. The conflicts which can occur between
the boundaries of new and existing code, can be discovered by the developers
at an early stage of development, as at that time it is relatively easy to
reconcile. Once all the conflicts are resolved successfully, the developers
can go on with the further development of the code with the complete
confidence that the new code which they will be writing, will show no conflicts
and will respect the existing code base.

The Integration practices with respect to the Continuous Integration helps us
ton automate the build process of the application and to automate the testing process.
When a developer merges the code with the main branch or on the basis of the 
configuration mentioned by the user at the time of pushing the code into the 
Version Control System, an automates process is kicked off which initiates the 
build process of the code written the repository of the version control system.
At the time of building the repository, the automated test suites are executed
and automation testing is performed. If the test cases fails in that case the 
build also fails and the team is notified regarding the failure of the build,
so that the team can work together to fix the build.

The main purpose of the Continuous Integration is to simplify the process of 
integration of different branches of the repository at an early stage of development
to reduce the integration cost and to fix the defects as early as possible in the
development cycle. It makes sure that the system we are trying to build is robust,
automated and fast.
------------------------------------------------------------------------------------------


Continuouos Delivery:
------------------------

Reference: https://www.linkedin.com/pulse/introduction-continuous-integration-delivery-rajesh-gurram

The process of Continuous Integration leads us to the process of Continuous Delivery.
Using Continuous Integration the development team ensures that they can reduce the
integration cost by integrating the code branches of the repository at an early stage
of development, whereas in the process of Continuous Delivery, the development team
tries to maintain a deployable code at the main branch i.e.; the production ready code.
It ensures us that the code base is always in a deployable state , which makes the 
releasing of code as an unremarkable event, as the new releases can be brought
to the production environment without any complicated coordination or the late stage
testing.

Continuous Delivery make the use of the deployment pipeline of which the process
of Continuous Integration is an essential part. A deployment pipeline is an automated
system that executes the test cases on the build increasingly and in a sequence
of stages. Continuous Delivery picks up where the Continuous Integration leaves
in the deployment pipeline.

When the code is passed on for building and the test cases are performed on
the code then the test cases are either passed or the test cases are failed
which raises an alert to the development team to perform the fix operation 
on the build. This process occurs at the each stage of development. Once the
build is passed then the build is deployed to the environment which mirrors
the production environment as exact as possible. This deployment helps us to
test the build, the deployment process and the environment of the production
altogether. This pipepline ends when the build is deployed to the production
environment finally.
------------------------------------------------------------------------------------------

Continuous Deployment:
------------------------

Reference: https://www.linkedin.com/pulse/introduction-continuous-integration-delivery-rajesh-gurram

Continuous Delivery is an initial process for the Continuouos Deployment which
deals with the automation of the deployment process by removing the need for the
human intervention for making decisions regarding choice of what and when to 
deploy to the production environment. It deploys everything that has successfully 
passed the delivery pipeline. Though the deployment system deploys everything 
which has passed the delivery pipepline, still we can implement new features 
for all the users or a subset of users of the application at any point of time
later in the deployment process. It helps us to deploy the new features at the 
runtime for the customers quickly and removes all sort of confusions and bugs 
which are present in the current release of the system.

The Continuous Deployment can cause be a source of some of sort of tension for the 
organisations who are worried about redesigning the workflow of the automation
system for the organization. The trade-off offered by the automated deployment is 
sometimes considered to be too dangerous for the payoff they provide. 

Continuous Deployment always follows the best practises and helps us to implement
the limited testing into the production as the code is already built and tested
at the time of building the code in the environment similar to the production. 
Developers must take the complete responsibility of the code which they are about
to deploy finally into the production environment and must ensure that their code
is well designed and tested. This gives the development team the complete authority
to decide that what and when to commit to the main branch and what and when to 
deploy to the production environment.

Feedback is must for any organization whether it is an IT organization or not.
Continuous Deployment helps us to get the early feedbacks from the users on the
application which is deployed. Features can be immidiately made available to the 
users. This will help the team to catch most of the defects and exceptions into
code at an early stage, before they tend to move the development into an 
uproductive direction. This is done because of the defects and bugs are not 
caught at an early stage then this might lead us to a bigger issue at the later
stages in the development lifecycle of the application.
------------------------------------------------------------------------------------

Test Deriven Development:
--------------------------

Contrary to the conventional approach of software development where the code is
developed first and then the testing is performed on it to check the legibility 
of the code that is written, the Test Driven Development asks us to divide the 
complete project into smaller stories or epics and write the test cases for a
particular module against its requirements. Once the test cases are made, then 
the development process it initiated. Once the developed code passes all the
test cases which have been written for the module, then the code which is developed
is accepted. The testing of the developed code is automated with the help of the
Continuous Integration engines which helps us to build the developed code and
perform the testing on it in an environment which is similar to the production
environment. This approach of software development helps the developer to design
efficient code and to build confidence for the developed code.

American software engineer Kent Beck, who is credited with having developed or 
"rediscovered" the technique, stated in 2003 that TDD encourages simple designs
and inspires confidence. 

[Ref: Kent Beck (May 11, 2012). "Why does Kent Beck refer to the 
"rediscovery" of test-driven development?". Retrieved December 1, 2014. ]
[Ref: Beck, K. Test-Driven Development by Example, Addison Wesley - Vaseem, 2003 ]


According to the book Test-Driven Development by Example,[Ref: Beck, K. Test-Driven Development by Example, Addison Wesley - Vaseem, 2003 ]
the following sequence of steps can be used to successfully follow this way of development :

1) Add test:-
**************

Developer must have the clear understanding of the requirements and the specifications
of features which he is supposed to develop the code for. To get a clear cut understanding
of the requirement and specifications, the developer must be well versed with the
use cases and the user stories and then decide that exceptional conditions. Once
the requirements and the specifications are clear to the developer, then he can 
start writting the test cases for those features. These test cases infact can be
the improved version of the previously written test cases.

This development technique is actually different from the traditional unit testing
approach as in this case we are focus on the requirement for writting the test cases
rather developing the code.

2) Run all the test and see if the new test fails
**************************************************

3) Write the code
******************

4) Run tests
**************

5) Refactor code
*****************

6) Repeat
**********


